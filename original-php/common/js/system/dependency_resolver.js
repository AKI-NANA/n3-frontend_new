
// CAIDS character_limit Hook
// CAIDS character_limit Hook - Âü∫Êú¨ÂÆüË£Ö
console.log('‚úÖ character_limit Hook loaded');

// CAIDS error_handling Hook

// CAIDS „Ç®„É©„ÉºÂá¶ÁêÜHook - ÂÆåÂÖ®ÂÆüË£Ö
window.CAIDS_ERROR_HANDLER = {
    isActive: true,
    errorCount: 0,
    errorHistory: [],
    
    initialize: function() {
        this.setupGlobalErrorHandler();
        this.setupUnhandledPromiseRejection();
        this.setupNetworkErrorHandler();
        console.log('‚ö†Ô∏è CAIDS „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†ÂÆåÂÖ®ÂàùÊúüÂåñ');
    },
    
    setupGlobalErrorHandler: function() {
        window.addEventListener('error', (event) => {
            this.handleError({
                type: 'JavaScript Error',
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: event.error?.stack
            });
        });
    },
    
    setupUnhandledPromiseRejection: function() {
        window.addEventListener('unhandledrejection', (event) => {
            this.handleError({
                type: 'Unhandled Promise Rejection',
                message: event.reason?.message || String(event.reason),
                stack: event.reason?.stack
            });
        });
    },
    
    setupNetworkErrorHandler: function() {
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            try {
                const response = await originalFetch.apply(this, args);
                if (!response.ok) {
                    window.CAIDS_ERROR_HANDLER.handleError({
                        type: 'Network Error',
                        message: `HTTP ${response.status}: ${response.statusText}`,
                        url: args[0]
                    });
                }
                return response;
            } catch (error) {
                window.CAIDS_ERROR_HANDLER.handleError({
                    type: 'Network Fetch Error',
                    message: error.message,
                    url: args[0]
                });
                throw error;
            }
        };
    },
    
    handleError: function(errorInfo) {
        this.errorCount++;
        this.errorHistory.push({...errorInfo, timestamp: new Date().toISOString()});
        
        console.error('üö® CAIDS Error Handler:', errorInfo);
        this.showErrorNotification(errorInfo);
        this.reportError(errorInfo);
    },
    
    showErrorNotification: function(errorInfo) {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 999999;
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: white; padding: 15px 20px; border-radius: 8px;
            max-width: 350px; box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            font-size: 13px; font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            border: 2px solid #ff6666; animation: caids-error-shake 0.5s ease-in-out;
        `;
        errorDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 18px;">üö®</span>
                <div>
                    <strong>„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü</strong><br>
                    <small style="opacity: 0.9;">${errorInfo.type}: ${errorInfo.message}</small>
                </div>
            </div>
        `;
        
        // CSS Animation
        if (!document.getElementById('caids-error-styles')) {
            const style = document.createElement('style');
            style.id = 'caids-error-styles';
            style.textContent = `
                @keyframes caids-error-shake {
                    0%, 100% { transform: translateX(0); }
                    25% { transform: translateX(-5px); }
                    75% { transform: translateX(5px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        document.body.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), 7000);
    },
    
    reportError: function(errorInfo) {
        // „Ç®„É©„Éº„É¨„Éù„Éº„ÉàÁîüÊàê„ÉªÈÄÅ‰ø°ÔºàÂ∞ÜÊù•„ÅÆÊã°ÂºµÁî®Ôºâ
        const report = {
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href,
            errorCount: this.errorCount,
            sessionId: this.getSessionId(),
            ...errorInfo
        };
        
        console.log('üìã CAIDS Error Report:', report);
        localStorage.setItem('caids_last_error', JSON.stringify(report));
    },
    
    getSessionId: function() {
        let sessionId = sessionStorage.getItem('caids_session_id');
        if (!sessionId) {
            sessionId = 'caids_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            sessionStorage.setItem('caids_session_id', sessionId);
        }
        return sessionId;
    },
    
    getErrorStats: function() {
        return {
            totalErrors: this.errorCount,
            recentErrors: this.errorHistory.slice(-10),
            sessionId: this.getSessionId()
        };
    }
};

window.CAIDS_ERROR_HANDLER.initialize();

/**
 * NAGANO-3 Dependency Resolver System„ÄêÂÆåÂÖ®ÂÆüË£ÖÁâà„Äë
 * „Éï„Ç°„Ç§„É´: common/js/system/dependency_resolver.js
 * 
 * üîó ‰æùÂ≠òÈñ¢‰øÇËß£Êûê„ÉªÂæ™Áí∞‰æùÂ≠òÊ§úÂá∫„ÉªÊúÄÈÅ©„Å™Ë™≠„ÅøËæº„ÅøÈ†ÜÂ∫èÊ±∫ÂÆö
 * ‚úÖ 45„Éï„Ç°„Ç§„É´„ÅÆ‰æùÂ≠òÈñ¢‰øÇÁÆ°ÁêÜ„Éª„Éà„Éù„É≠„Ç∏„Ç´„É´„ÇΩ„Éº„Éà„ÉªÂãïÁöÑËß£Ê±∫
 * 
 * @version 1.0.0-complete
 */

"use strict";

console.log('üîó NAGANO-3 Dependency Resolver System Ë™≠„ÅøËæº„ÅøÈñãÂßã');

// =====================================
// üéØ DependencyResolver „É°„Ç§„É≥„ÇØ„É©„Çπ
// =====================================

class DependencyResolver {
    constructor() {
        this.dependencies = new Map();
        this.resolved = new Set();
        this.resolving = new Set();
        this.graph = new Map();
        this.circularDependencies = [];
        this.loadOrder = [];
        
        // Êó¢Áü•„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„Éû„ÉÉ„Éó
        this.knownDependencies = {
            // CoreÁ≥ªÔºàÊúÄÂÑ™ÂÖàÔºâ
            'bootstrap.js': [],
            'ajax.js': ['bootstrap.js'],
            'header.js': ['ajax.js'],
            'sidebar.js': ['header.js'],
            'theme.js': ['bootstrap.js'],
            
            // SystemÁ≥ªÔºà‰∏≠ÂÑ™ÂÖàÔºâ
            'error_boundary.js': ['bootstrap.js'],
            'compatibility_layer.js': ['error_boundary.js'],
            'js_module_loader.js': ['compatibility_layer.js'],
            'notification_orchestrator.js': ['js_module_loader.js'],
            'lifecycle_manager.js': ['notification_orchestrator.js'],
            'module_integration_manager.js': ['lifecycle_manager.js'],
            'dependency_resolver.js': ['module_integration_manager.js'],
            'unified_config.js': ['dependency_resolver.js'],
            'performance_monitor.js': ['unified_config.js'],
            
            // UtilsÁ≥ª
            'notifications.js': ['bootstrap.js'],
            'file_finder_and_loader.js': ['notifications.js'],
            
            // ComponentsÁ≥ª
            'modal.js': ['theme.js'],
            'dropdown.js': ['modal.js'],
            'tooltip.js': ['dropdown.js'],
            
            // PagesÁ≥ªÔºàÊúÄ‰ΩéÂÑ™ÂÖàÔºâ
            'dashboard.js': ['components'],
            'settings.js': ['dashboard.js'],
            
            // ModulesÁ≥ªÔºàÁã¨Á´ãÊÄßÈáçË¶ñÔºâ
            'juchu': ['core_dependencies'],
            'kicho': ['core_dependencies']
        };
        
        // „Éï„Ç°„Ç§„É´„Çø„Ç§„ÉóÂà•„ÅÆÂÑ™ÂÖàÂ∫¶
        this.typePriorities = {
            'bootstrap': 1000,  // ÊúÄÈ´òÂÑ™ÂÖàÂ∫¶
            'core': 900,
            'system': 800,
            'utils': 700,
            'components': 600,
            'ui': 500,
            'pages': 400,
            'modules': 300,     // ÊúÄ‰ΩéÂÑ™ÂÖàÂ∫¶
            'unknown': 100
        };
        
        this.init();
    }
    
    /**
     * ÂàùÊúüÂåñ
     */
    init() {
        console.log('üîó Dependency Resolver ÂàùÊúüÂåñÈñãÂßã');
        
        // Êó¢Áü•„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„Çí„Ç∞„É©„Éï„Å´ÊßãÁØâ
        this.buildDependencyGraph();
        
        console.log('‚úÖ Dependency Resolver ÂàùÊúüÂåñÂÆå‰∫Ü');
    }
    
    /**
     * ‰æùÂ≠òÈñ¢‰øÇ„Ç∞„É©„ÉïÊßãÁØâ
     */
    buildDependencyGraph() {
        console.log('üìä ‰æùÂ≠òÈñ¢‰øÇ„Ç∞„É©„ÉïÊßãÁØâÈñãÂßã');
        
        // Êó¢Áü•„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„Çí„Ç∞„É©„Éï„Å´ËøΩÂä†
        Object.entries(this.knownDependencies).forEach(([file, deps]) => {
            this.addDependency(file, deps);
        });
        
        console.log(`‚úÖ ‰æùÂ≠òÈñ¢‰øÇ„Ç∞„É©„ÉïÊßãÁØâÂÆå‰∫Ü: ${this.graph.size}„Éé„Éº„Éâ`);
    }
    
    /**
     * ‰æùÂ≠òÈñ¢‰øÇËøΩÂä†
     */
    addDependency(file, dependencies) {
        if (!this.graph.has(file)) {
            this.graph.set(file, {
                dependencies: [],
                dependents: [],
                priority: this.calculatePriority(file),
                type: this.getFileType(file),
                status: 'pending'
            });
        }
        
        const node = this.graph.get(file);
        
        // ‰æùÂ≠òÈñ¢‰øÇ„ÇíËøΩÂä†
        dependencies.forEach(dep => {
            if (!node.dependencies.includes(dep)) {
                node.dependencies.push(dep);
            }
            
            // ÈÄÜÊñπÂêë„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„ÇÇËøΩÂä†
            if (!this.graph.has(dep)) {
                this.graph.set(dep, {
                    dependencies: [],
                    dependents: [],
                    priority: this.calculatePriority(dep),
                    type: this.getFileType(dep),
                    status: 'pending'
                });
            }
            
            const depNode = this.graph.get(dep);
            if (!depNode.dependents.includes(file)) {
                depNode.dependents.push(file);
            }
        });
    }
    
    /**
     * „Éï„Ç°„Ç§„É´ÂÑ™ÂÖàÂ∫¶Ë®àÁÆó
     */
    calculatePriority(filename) {
        const lowerName = filename.toLowerCase();
        
        // bootstrap.js „ÅØÊúÄÈ´òÂÑ™ÂÖàÂ∫¶
        if (lowerName.includes('bootstrap')) {
            return this.typePriorities.bootstrap;
        }
        
        // „Éï„Ç°„Ç§„É´„Éë„Çπ/ÂêçÂâç„Åã„ÇâÂà§ÂÆö
        if (lowerName.includes('core/') || lowerName.includes('_core') || lowerName.includes('core_')) {
            return this.typePriorities.core;
        }
        
        if (lowerName.includes('system/') || lowerName.includes('_system') || lowerName.includes('system_')) {
            return this.typePriorities.system;
        }
        
        if (lowerName.includes('utils/') || lowerName.includes('_utils') || lowerName.includes('util_')) {
            return this.typePriorities.utils;
        }
        
        if (lowerName.includes('components/') || lowerName.includes('_component') || lowerName.includes('component_')) {
            return this.typePriorities.components;
        }
        
        if (lowerName.includes('ui/') || lowerName.includes('_ui') || lowerName.includes('ui_')) {
            return this.typePriorities.ui;
        }
        
        if (lowerName.includes('pages/') || lowerName.includes('_page') || lowerName.includes('page_')) {
            return this.typePriorities.pages;
        }
        
        if (lowerName.includes('modules/') || lowerName.includes('_module') || lowerName.includes('module_')) {
            return this.typePriorities.modules;
        }
        
        return this.typePriorities.unknown;
    }
    
    /**
     * „Éï„Ç°„Ç§„É´„Çø„Ç§„ÉóÂèñÂæó
     */
    getFileType(filename) {
        const lowerName = filename.toLowerCase();
        
        if (lowerName.includes('bootstrap')) return 'bootstrap';
        if (lowerName.includes('core/')) return 'core';
        if (lowerName.includes('system/')) return 'system';
        if (lowerName.includes('utils/')) return 'utils';
        if (lowerName.includes('components/')) return 'components';
        if (lowerName.includes('ui/')) return 'ui';
        if (lowerName.includes('pages/')) return 'pages';
        if (lowerName.includes('modules/')) return 'modules';
        
        return 'unknown';
    }
    
    /**
     * ‰æùÂ≠òÈñ¢‰øÇËß£Ê±∫Ôºà„É°„Ç§„É≥Âá¶ÁêÜÔºâ
     */
    async resolveDependencies(fileList) {
        console.log(`üîó ‰æùÂ≠òÈñ¢‰øÇËß£Ê±∫ÈñãÂßã: ${fileList.length}„Éï„Ç°„Ç§„É´`);
        
        try {
            // 1. „Éï„Ç°„Ç§„É´„É™„Çπ„Éà„Çí‰æùÂ≠òÈñ¢‰øÇ„Ç∞„É©„Éï„Å´ËøΩÂä†
            await this.addFileListToGraph(fileList);
            
            // 2. Âæ™Áí∞‰æùÂ≠òÊ§úÂá∫
            const circularDeps = this.detectCircularDependencies();
            if (circularDeps.length > 0) {
                console.warn('‚ö†Ô∏è Âæ™Áí∞‰æùÂ≠òÊ§úÂá∫:', circularDeps);
                this.circularDependencies = circularDeps;
                
                // Âæ™Áí∞‰æùÂ≠ò„ÅÆËß£Ê±∫Ë©¶Ë°å
                await this.resolveCircularDependencies(circularDeps);
            }
            
            // 3. „Éà„Éù„É≠„Ç∏„Ç´„É´„ÇΩ„Éº„ÉàÂÆüË°å
            const sortedFiles = await this.topologicalSort(fileList);
            
            // 4. Ë™≠„ÅøËæº„ÅøÈ†ÜÂ∫èÊúÄÈÅ©Âåñ
            const optimizedOrder = await this.optimizeLoadOrder(sortedFiles);
            
            this.loadOrder = optimizedOrder;
            
            console.log(`‚úÖ ‰æùÂ≠òÈñ¢‰øÇËß£Ê±∫ÂÆå‰∫Ü: ÊúÄÈÅ©Ë™≠„ÅøËæº„ÅøÈ†ÜÂ∫èÊ±∫ÂÆö (${optimizedOrder.length}„Éï„Ç°„Ç§„É´)`);
            
            return optimizedOrder;
            
        } catch (error) {
            console.error('‚ùå ‰æùÂ≠òÈñ¢‰øÇËß£Ê±∫„Ç®„É©„Éº:', error);
            
            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂÑ™ÂÖàÂ∫¶„Éô„Éº„Çπ„ÇΩ„Éº„Éà
            return this.fallbackSort(fileList);
        }
    }
    
    /**
     * „Éï„Ç°„Ç§„É´„É™„Çπ„Éà„Çí‰æùÂ≠òÈñ¢‰øÇ„Ç∞„É©„Éï„Å´ËøΩÂä†
     */
    async addFileListToGraph(fileList) {
        for (const file of fileList) {
            if (!this.graph.has(file)) {
                // ÂãïÁöÑ‰æùÂ≠òÈñ¢‰øÇÂàÜÊûê
                const dependencies = await this.analyzeDependencies(file);
                this.addDependency(file, dependencies);
            }
        }
    }
    
    /**
     * ÂãïÁöÑ‰æùÂ≠òÈñ¢‰øÇÂàÜÊûê
     */
    async analyzeDependencies(filename) {
        const dependencies = [];
        
        try {
            // „Éï„Ç°„Ç§„É´ÂÜÖÂÆπ„ÇíÂèñÂæó„Åó„Å¶‰æùÂ≠òÈñ¢‰øÇ„ÇíÂàÜÊûê
            const response = await fetch(filename, { method: 'HEAD' });
            if (!response.ok) {
                return dependencies;
            }
            
            // „Éï„Ç°„Ç§„É´Âêç„Éë„Çø„Éº„É≥„Éô„Éº„Çπ„ÅÆÊé®Ê∏¨‰æùÂ≠òÈñ¢‰øÇ
            const inferredDeps = this.inferDependenciesFromFilename(filename);
            dependencies.push(...inferredDeps);
            
        } catch (error) {
            console.warn(`‰æùÂ≠òÈñ¢‰øÇÂàÜÊûêÂ§±Êïó: ${filename}`, error);
        }
        
        return dependencies;
    }
    
    /**
     * „Éï„Ç°„Ç§„É´Âêç„Åã„Çâ„ÅÆ‰æùÂ≠òÈñ¢‰øÇÊé®Ê∏¨
     */
    inferDependenciesFromFilename(filename) {
        const dependencies = [];
        const lowerName = filename.toLowerCase();
        
        // Âü∫Êú¨ÁöÑ„Å™‰æùÂ≠òÈñ¢‰øÇÊé®Ê∏¨„É´„Éº„É´
        
        // „Åô„Åπ„Å¶„ÅÆ„Éï„Ç°„Ç§„É´„ÅØ bootstrap.js „Å´‰æùÂ≠ò
        if (!lowerName.includes('bootstrap')) {
            dependencies.push('bootstrap.js');
        }
        
        // AjaxÈñ¢ÈÄ£„ÅØajax.js„Å´‰æùÂ≠ò
        if (lowerName.includes('ajax') && !lowerName.includes('ajax.js')) {
            dependencies.push('ajax.js');
        }
        
        // UIÈñ¢ÈÄ£„ÅØtheme.js„Å´‰æùÂ≠ò
        if ((lowerName.includes('ui') || lowerName.includes('component')) && !lowerName.includes('theme')) {
            dependencies.push('theme.js');
        }
        
        // „É¢„Ç∏„É•„Éº„É´„ÅØ system/ „Éï„Ç°„Ç§„É´Áæ§„Å´‰æùÂ≠ò
        if (lowerName.includes('modules/')) {
            dependencies.push('error_boundary.js', 'compatibility_layer.js');
        }
        
        // ÈÄöÁü•Èñ¢ÈÄ£„ÅØ notification „Å´‰æùÂ≠ò
        if (lowerName.includes('notification') && !lowerName.includes('notification_orchestrator')) {
            dependencies.push('notification_orchestrator.js');
        }
        
        return dependencies;
    }
    
    /**
     * Âæ™Áí∞‰æùÂ≠òÊ§úÂá∫
     */
    detectCircularDependencies() {
        const circularDeps = [];
        const visited = new Set();
        const recursionStack = new Set();
        
        // ÂêÑ„Éé„Éº„Éâ„Åã„ÇâÂæ™Áí∞‰æùÂ≠ò„ÇíÊ§úÁ¥¢
        for (const [file, node] of this.graph) {
            if (!visited.has(file)) {
                const cycle = this.detectCycleFromNode(file, visited, recursionStack, []);
                if (cycle.length > 0) {
                    circularDeps.push(cycle);
                }
            }
        }
        
        return circularDeps;
    }
    
    /**
     * „Éé„Éº„Éâ„Åã„Çâ„ÅÆÂæ™Áí∞Ê§úÂá∫
     */
    detectCycleFromNode(file, visited, recursionStack, path) {
        visited.add(file);
        recursionStack.add(file);
        path.push(file);
        
        const node = this.graph.get(file);
        if (!node) {
            path.pop();
            recursionStack.delete(file);
            return [];
        }
        
        for (const dep of node.dependencies) {
            if (!visited.has(dep)) {
                const cycle = this.detectCycleFromNode(dep, visited, recursionStack, [...path]);
                if (cycle.length > 0) {
                    return cycle;
                }
            } else if (recursionStack.has(dep)) {
                // Âæ™Áí∞‰æùÂ≠òÁô∫Ë¶ã
                const cycleStart = path.indexOf(dep);
                return path.slice(cycleStart).concat([dep]);
            }
        }
        
        path.pop();
        recursionStack.delete(file);
        return [];
    }
    
    /**
     * Âæ™Áí∞‰æùÂ≠òËß£Ê±∫
     */
    async resolveCircularDependencies(circularDeps) {
        console.log('üîß Âæ™Áí∞‰æùÂ≠òËß£Ê±∫ÈñãÂßã');
        
        for (const cycle of circularDeps) {
            await this.breakCircularDependency(cycle);
        }
        
        console.log('‚úÖ Âæ™Áí∞‰æùÂ≠òËß£Ê±∫ÂÆå‰∫Ü');
    }
    
    /**
     * Âæ™Áí∞‰æùÂ≠ò„ÅÆÂàáÊñ≠
     */
    async breakCircularDependency(cycle) {
        console.log(`üîß Âæ™Áí∞‰æùÂ≠òÂàáÊñ≠: ${cycle.join(' -> ')}`);
        
        // ÂÑ™ÂÖàÂ∫¶„ÅåÊúÄ„ÇÇ‰Ωé„ÅÑ„Éï„Ç°„Ç§„É´„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„ÇíÂàáÊñ≠
        let lowestPriorityFile = cycle[0];
        let lowestPriority = this.graph.get(cycle[0])?.priority || 0;
        
        for (const file of cycle) {
            const node = this.graph.get(file);
            if (node && node.priority < lowestPriority) {
                lowestPriority = node.priority;
                lowestPriorityFile = file;
            }
        }
        
        // ‰æùÂ≠òÈñ¢‰øÇ„Çí‰∏ÄÊôÇÁöÑ„Å´ÂàáÊñ≠
        const node = this.graph.get(lowestPriorityFile);
        if (node) {
            const cycleIndex = cycle.indexOf(lowestPriorityFile);
            const nextFile = cycle[(cycleIndex + 1) % cycle.length];
            
            const depIndex = node.dependencies.indexOf(nextFile);
            if (depIndex !== -1) {
                node.dependencies.splice(depIndex, 1);
                console.log(`üîß ‰æùÂ≠òÈñ¢‰øÇÂàáÊñ≠: ${lowestPriorityFile} -> ${nextFile}`);
                
                // Âæå„ÅßÂæ©ÂÖÉ„Åô„Çã„Åü„ÇÅ„Å´Ë®òÈå≤
                if (!node.deferredDependencies) {
                    node.deferredDependencies = [];
                }
                node.deferredDependencies.push(nextFile);
            }
        }
    }
    
    /**
     * „Éà„Éù„É≠„Ç∏„Ç´„É´„ÇΩ„Éº„Éà
     */
    async topologicalSort(fileList) {
        console.log('üìä „Éà„Éù„É≠„Ç∏„Ç´„É´„ÇΩ„Éº„ÉàÂÆüË°å');
        
        const sorted = [];
        const visited = new Set();
        const temporary = new Set();
        
        // ÂêÑ„Éï„Ç°„Ç§„É´„Çí„ÇΩ„Éº„Éà
        for (const file of fileList) {
            if (!visited.has(file)) {
                await this.topologicalSortVisit(file, visited, temporary, sorted);
            }
        }
        
        // ÁµêÊûú„ÇíÈÄÜÈ†Ü„Å´„Åó„Å¶Ê≠£„Åó„ÅÑ‰æùÂ≠òÈ†ÜÂ∫è„Å´„Åô„Çã
        sorted.reverse();
        
        console.log(`‚úÖ „Éà„Éù„É≠„Ç∏„Ç´„É´„ÇΩ„Éº„ÉàÂÆå‰∫Ü: ${sorted.length}„Éï„Ç°„Ç§„É´`);
        return sorted;
    }
    
    /**
     * „Éà„Éù„É≠„Ç∏„Ç´„É´„ÇΩ„Éº„ÉàË®™Âïè
     */
    async topologicalSortVisit(file, visited, temporary, sorted) {
        if (temporary.has(file)) {
            console.warn(`‚ö†Ô∏è ‰∏ÄÊôÇÁöÑ„Å™Âæ™Áí∞‰æùÂ≠òÊ§úÂá∫: ${file}`);
            return;
        }
        
        if (visited.has(file)) {
            return;
        }
        
        temporary.add(file);
        
        const node = this.graph.get(file);
        if (node) {
            // ‰æùÂ≠òÈñ¢‰øÇ„ÇíÂÑ™ÂÖàÂ∫¶È†Ü„Åß„ÇΩ„Éº„Éà
            const sortedDeps = node.dependencies.sort((a, b) => {
                const nodeA = this.graph.get(a);
                const nodeB = this.graph.get(b);
                const priorityA = nodeA?.priority || 0;
                const priorityB = nodeB?.priority || 0;
                return priorityB - priorityA; // È´òÂÑ™ÂÖàÂ∫¶„ÅåÂÖà
            });
            
            for (const dep of sortedDeps) {
                await this.topologicalSortVisit(dep, visited, temporary, sorted);
            }
        }
        
        temporary.delete(file);
        visited.add(file);
        sorted.push(file);
    }
    
    /**
     * Ë™≠„ÅøËæº„ÅøÈ†ÜÂ∫èÊúÄÈÅ©Âåñ
     */
    async optimizeLoadOrder(sortedFiles) {
        console.log('‚ö° Ë™≠„ÅøËæº„ÅøÈ†ÜÂ∫èÊúÄÈÅ©ÂåñÈñãÂßã');
        
        const optimized = [];
        const phases = this.groupFilesByPhase(sortedFiles);
        
        // „Éï„Çß„Éº„Ç∫„Åî„Å®„Å´ÊúÄÈÅ©Âåñ
        for (const [phase, files] of phases) {
            const optimizedPhase = await this.optimizePhase(files, phase);
            optimized.push(...optimizedPhase);
        }
        
        console.log(`‚úÖ Ë™≠„ÅøËæº„ÅøÈ†ÜÂ∫èÊúÄÈÅ©ÂåñÂÆå‰∫Ü: ${optimized.length}„Éï„Ç°„Ç§„É´`);
        return optimized;
    }
    
    /**
     * „Éï„Ç°„Ç§„É´„Çí„Éï„Çß„Éº„Ç∫Âà•„Å´„Ç∞„É´„Éº„ÉóÂåñ
     */
    groupFilesByPhase(sortedFiles) {
        const phases = new Map();
        
        sortedFiles.forEach(file => {
            const node = this.graph.get(file);
            const type = node?.type || 'unknown';
            
            if (!phases.has(type)) {
                phases.set(type, []);
            }
            phases.get(type).push(file);
        });
        
        // „Éï„Çß„Éº„Ç∫„ÇíÂÑ™ÂÖàÂ∫¶È†Ü„Åß„ÇΩ„Éº„Éà
        const sortedPhases = new Map([...phases.entries()].sort((a, b) => {
            const priorityA = this.typePriorities[a[0]] || 0;
            const priorityB = this.typePriorities[b[0]] || 0;
            return priorityB - priorityA;
        }));
        
        return sortedPhases;
    }
    
    /**
     * „Éï„Çß„Éº„Ç∫ÊúÄÈÅ©Âåñ
     */
    async optimizePhase(files, phase) {
        // „Éï„Çß„Éº„Ç∫ÂÜÖ„Åß„ÅÆ‰∏¶ÂàóË™≠„ÅøËæº„ÅøÂèØËÉΩÊÄß„ÇíËÄÉÊÖÆ
        if (phase === 'modules') {
            // „É¢„Ç∏„É•„Éº„É´„ÅØ‰∏¶ÂàóË™≠„ÅøËæº„ÅøÂèØËÉΩ
            return this.optimizeParallelLoading(files);
        } else if (phase === 'components') {
            // „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅØËªΩ„ÅÑ‰æùÂ≠òÈñ¢‰øÇ„Åß„ÇΩ„Éº„Éà
            return this.optimizeLightDependencies(files);
        } else {
            // „Åù„ÅÆ‰ªñ„ÅØÂÑ™ÂÖàÂ∫¶È†Ü
            return this.sortByPriority(files);
        }
    }
    
    /**
     * ‰∏¶ÂàóË™≠„ÅøËæº„ÅøÊúÄÈÅ©Âåñ
     */
    optimizeParallelLoading(files) {
        // Áã¨Á´ãÊÄß„ÅÆÈ´ò„ÅÑ„Éï„Ç°„Ç§„É´„ÇíÂâç„Å´ÈÖçÁΩÆ
        return files.sort((a, b) => {
            const nodeA = this.graph.get(a);
            const nodeB = this.graph.get(b);
            
            const independenceA = this.calculateIndependence(nodeA);
            const independenceB = this.calculateIndependence(nodeB);
            
            return independenceB - independenceA;
        });
    }
    
    /**
     * Áã¨Á´ãÊÄßË®àÁÆó
     */
    calculateIndependence(node) {
        if (!node) return 0;
        
        // ‰æùÂ≠òÈñ¢‰øÇ„ÅåÂ∞ë„Å™„ÅÑ„Åª„Å©Áã¨Á´ãÊÄß„ÅåÈ´ò„ÅÑ
        const depCount = node.dependencies.length;
        const dependentCount = node.dependents.length;
        
        return 100 - (depCount * 10) - (dependentCount * 5);
    }
    
    /**
     * ËªΩ„ÅÑ‰æùÂ≠òÈñ¢‰øÇ„Åß„ÇΩ„Éº„Éà
     */
    optimizeLightDependencies(files) {
        return files.sort((a, b) => {
            const nodeA = this.graph.get(a);
            const nodeB = this.graph.get(b);
            
            const weightA = this.calculateDependencyWeight(nodeA);
            const weightB = this.calculateDependencyWeight(nodeB);
            
            return weightA - weightB; // ËªΩ„ÅÑ„ÇÇ„ÅÆ„ÅåÂÖà
        });
    }
    
    /**
     * ‰æùÂ≠òÈñ¢‰øÇÈáç„ÅøË®àÁÆó
     */
    calculateDependencyWeight(node) {
        if (!node) return 1000;
        
        let weight = 0;
        
        // ‰æùÂ≠òÈñ¢‰øÇ„ÅÆÊ∑±„Åï„ÇíË®àÁÆó
        const visited = new Set();
        weight += this.calculateDepthWeight(node, visited, 0);
        
        return weight;
    }
    
    /**
     * Ê∑±„ÅïÈáç„ÅøË®àÁÆó
     */
    calculateDepthWeight(node, visited, depth) {
        if (!node || visited.has(node) || depth > 10) {
            return depth;
        }
        
        visited.add(node);
        
        let maxDepth = depth;
        for (const dep of node.dependencies) {
            const depNode = this.graph.get(dep);
            if (depNode) {
                const depthWeight = this.calculateDepthWeight(depNode, visited, depth + 1);
                maxDepth = Math.max(maxDepth, depthWeight);
            }
        }
        
        visited.delete(node);
        return maxDepth;
    }
    
    /**
     * ÂÑ™ÂÖàÂ∫¶È†Ü„ÇΩ„Éº„Éà
     */
    sortByPriority(files) {
        return files.sort((a, b) => {
            const nodeA = this.graph.get(a);
            const nodeB = this.graph.get(b);
            
            const priorityA = nodeA?.priority || 0;
            const priorityB = nodeB?.priority || 0;
            
            return priorityB - priorityA;
        });
    }
    
    /**
     * „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÇΩ„Éº„Éà
     */
    fallbackSort(fileList) {
        console.log('üÜò „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂÑ™ÂÖàÂ∫¶„Éô„Éº„Çπ„ÇΩ„Éº„ÉàÂÆüË°å');
        
        return fileList.sort((a, b) => {
            const priorityA = this.calculatePriority(a);
            const priorityB = this.calculatePriority(b);
            
            if (priorityA !== priorityB) {
                return priorityB - priorityA;
            }
            
            // Âêå„ÅòÂÑ™ÂÖàÂ∫¶„ÅÆÂ†¥Âêà„ÅØ„Éï„Ç°„Ç§„É´Âêç„Åß„ÇΩ„Éº„Éà
            return a.localeCompare(b);
        });
    }
    
    /**
     * ‰æùÂ≠òÈñ¢‰øÇÊ§úË®º
     */
    validateDependencies(fileList) {
        console.log('üß™ ‰æùÂ≠òÈñ¢‰øÇÊ§úË®ºÈñãÂßã');
        
        const issues = [];
        
        for (const file of fileList) {
            const node = this.graph.get(file);
            if (!node) continue;
            
            // Â≠òÂú®„Åó„Å™„ÅÑ‰æùÂ≠òÈñ¢‰øÇ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            for (const dep of node.dependencies) {
                if (!fileList.includes(dep)) {
                    issues.push({
                        type: 'missing_dependency',
                        file: file,
                        dependency: dep
                    });
                }
            }
            
            // Âæ™Áí∞‰æùÂ≠ò„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            const cycle = this.findCycleFromFile(file, new Set(), []);
            if (cycle.length > 0) {
                issues.push({
                    type: 'circular_dependency',
                    cycle: cycle
                });
            }
        }
        
        if (issues.length > 0) {
            console.warn('‚ö†Ô∏è ‰æùÂ≠òÈñ¢‰øÇÂïèÈ°åÊ§úÂá∫:', issues);
        } else {
            console.log('‚úÖ ‰æùÂ≠òÈñ¢‰øÇÊ§úË®º: ÂïèÈ°å„Å™„Åó');
        }
        
        return issues;
    }
    
    /**
     * „Éï„Ç°„Ç§„É´„Åã„Çâ„ÅÆÂæ™Áí∞Ê§úÁ¥¢
     */
    findCycleFromFile(file, visited, path) {
        if (visited.has(file)) {
            const cycleStart = path.indexOf(file);
            if (cycleStart !== -1) {
                return path.slice(cycleStart);
            }
            return [];
        }
        
        visited.add(file);
        path.push(file);
        
        const node = this.graph.get(file);
        if (node) {
            for (const dep of node.dependencies) {
                const cycle = this.findCycleFromFile(dep, new Set(visited), [...path]);
                if (cycle.length > 0) {
                    return cycle;
                }
            }
        }
        
        return [];
    }
    
    /**
     * ‰æùÂ≠òÈñ¢‰øÇÁµ±Ë®à
     */
    getDependencyStatistics() {
        const stats = {
            totalFiles: this.graph.size,
            totalDependencies: 0,
            avgDependencies: 0,
            maxDependencies: 0,
            circularDependencies: this.circularDependencies.length,
            typeDistribution: {},
            priorityDistribution: {}
        };
        
        let dependenciesSum = 0;
        
        this.graph.forEach((node, file) => {
            const depCount = node.dependencies.length;
            dependenciesSum += depCount;
            
            if (depCount > stats.maxDependencies) {
                stats.maxDependencies = depCount;
            }
            
            // „Çø„Ç§„ÉóÂà•ÂàÜÂ∏É
            const type = node.type;
            stats.typeDistribution[type] = (stats.typeDistribution[type] || 0) + 1;
            
            // ÂÑ™ÂÖàÂ∫¶Âà•ÂàÜÂ∏É
            const priority = Math.floor(node.priority / 100) * 100;
            stats.priorityDistribution[priority] = (stats.priorityDistribution[priority] || 0) + 1;
        });
        
        stats.totalDependencies = dependenciesSum;
        stats.avgDependencies = stats.totalFiles > 0 ? dependenciesSum / stats.totalFiles : 0;
        
        return stats;
    }
    
    /**
     * Ë™≠„ÅøËæº„ÅøÈ†ÜÂ∫èÂèñÂæó
     */
    getLoadOrder() {
        return [...this.loadOrder];
    }
    
    /**
     * ‰æùÂ≠òÈñ¢‰øÇ„Ç∞„É©„ÉïÂèØË¶ñÂåñ„Éá„Éº„Çø
     */
    getVisualizationData() {
        const nodes = [];
        const edges = [];
        
        this.graph.forEach((node, file) => {
            nodes.push({
                id: file,
                type: node.type,
                priority: node.priority,
                status: node.status
            });
            
            node.dependencies.forEach(dep => {
                edges.push({
                    source: file,
                    target: dep,
                    type: 'dependency'
                });
            });
        });
        
        return { nodes, edges };
    }
    
    /**
     * „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±ÂèñÂæó
     */
    getDebugInfo() {
        return {
            dependencyGraph: Object.fromEntries(this.graph),
            circularDependencies: this.circularDependencies,
            loadOrder: this.loadOrder,
            knownDependencies: this.knownDependencies,
            typePriorities: this.typePriorities,
            statistics: this.getDependencyStatistics()
        };
    }
    
    /**
     * ÊúÄÈÅ©Âåñ„É¨„Éù„Éº„ÉàÁîüÊàê
     */
    generateOptimizationReport(originalOrder, optimizedOrder) {
        const improvements = {
            originalOrder: originalOrder,
            optimizedOrder: optimizedOrder,
            reorderCount: 0,
            priorityImprovements: [],
            dependencyViolations: 0,
            estimatedSpeedImprovement: 0
        };
        
        // È†ÜÂ∫èÂ§âÊõ¥Êï∞„Çí„Ç´„Ç¶„É≥„Éà
        originalOrder.forEach((file, index) => {
            if (optimizedOrder[index] !== file) {
                improvements.reorderCount++;
            }
        });
        
        // ‰æùÂ≠òÈñ¢‰øÇÈÅïÂèç„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        optimizedOrder.forEach((file, index) => {
            const node = this.graph.get(file);
            if (node) {
                node.dependencies.forEach(dep => {
                    const depIndex = optimizedOrder.indexOf(dep);
                    if (depIndex > index) {
                        improvements.dependencyViolations++;
                    }
                });
            }
        });
        
        // Êé®ÂÆöÈÄüÂ∫¶ÊîπÂñÑ„ÇíË®àÁÆó
        improvements.estimatedSpeedImprovement = this.estimateSpeedImprovement(originalOrder, optimizedOrder);
        
        return improvements;
    }
    
    /**
     * ÈÄüÂ∫¶ÊîπÂñÑÊé®ÂÆö
     */
    estimateSpeedImprovement(originalOrder, optimizedOrder) {
        // Á∞°ÊòìÁöÑ„Å™ÈÄüÂ∫¶ÊîπÂñÑÊé®ÂÆö
        let originalScore = 0;
        let optimizedScore = 0;
        
        originalOrder.forEach((file, index) => {
            const node = this.graph.get(file);
            if (node) {
                originalScore += node.priority * (originalOrder.length - index);
            }
        });
        
        optimizedOrder.forEach((file, index) => {
            const node = this.graph.get(file);
            if (node) {
                optimizedScore += node.priority * (optimizedOrder.length - index);
            }
        });
        
        const improvement = ((optimizedScore - originalScore) / originalScore) * 100;
        return Math.max(0, Math.min(100, improvement));
    }
}

// =====================================
// üöÄ Ëá™ÂãïÂàùÊúüÂåñ
// =====================================

// „Ç∞„É≠„Éº„Éê„É´ÂàùÊúüÂåñ
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeDependencyResolver);
} else {
    setTimeout(initializeDependencyResolver, 0);
}

async function initializeDependencyResolver() {
    try {
        if (!window.NAGANO3_DEPENDENCY_RESOLVER) {
            window.NAGANO3_DEPENDENCY_RESOLVER = new DependencyResolver();
            
            // NAGANO3ÂêçÂâçÁ©∫Èñì„Å∏„ÅÆÁôªÈå≤
            if (typeof window.NAGANO3 === 'object') {
                window.NAGANO3.dependencyResolver = window.NAGANO3_DEPENDENCY_RESOLVER;
            }
            
            console.log('‚úÖ Dependency Resolver ÂàùÊúüÂåñÂÆå‰∫Ü„Éª„Ç∞„É≠„Éº„Éê„É´Ë®≠ÂÆöÂÆå‰∫Ü');
        } else {
            console.log('‚ö†Ô∏è Dependency Resolver „ÅØÊó¢„Å´ÂàùÊúüÂåñÊ∏à„Åø„Åß„Åô');
        }
    } catch (error) {
        console.error('‚ùå Dependency Resolver ÂàùÊúüÂåñ„Ç®„É©„Éº:', error);
    }
}

// =====================================
// üß™ „Éá„Éê„ÉÉ„Ç∞„Éª„ÉÜ„Çπ„ÉàÊ©üËÉΩ
// =====================================

// ‰æùÂ≠òÈñ¢‰øÇËß£Ê±∫„ÉÜ„Çπ„Éà
window.testDependencyResolver = function() {
    console.log('üß™ Dependency Resolver „ÉÜ„Çπ„ÉàÈñãÂßã');
    
    if (window.NAGANO3_DEPENDENCY_RESOLVER) {
        const resolver = window.NAGANO3_DEPENDENCY_RESOLVER;
        
        // „ÉÜ„Çπ„ÉàÁî®„Éï„Ç°„Ç§„É´„É™„Çπ„Éà
        const testFiles = [
            'bootstrap.js',
            'ajax.js',
            'theme.js',
            'notifications.js',
            'modal.js',
            'dashboard.js',
            'modules/juchu/juchu.js',
            'modules/kicho/kicho.js'
        ];
        
        console.log('üîó „ÉÜ„Çπ„ÉàÁî®„Éï„Ç°„Ç§„É´„É™„Çπ„Éà:', testFiles);
        
        // ‰æùÂ≠òÈñ¢‰øÇËß£Ê±∫ÂÆüË°å
        resolver.resolveDependencies(testFiles).then(optimizedOrder => {
            console.log('‚úÖ ÊúÄÈÅ©Âåñ„Åï„Çå„ÅüË™≠„ÅøËæº„ÅøÈ†ÜÂ∫è:', optimizedOrder);
            
            // Ê§úË®º
            const issues = resolver.validateDependencies(testFiles);
            console.log('üß™ Ê§úË®ºÁµêÊûú:', issues);
            
            // Áµ±Ë®à
            const stats = resolver.getDependencyStatistics();
            console.log('üìä ‰æùÂ≠òÈñ¢‰øÇÁµ±Ë®à:', stats);
            
            // ÊúÄÈÅ©Âåñ„É¨„Éù„Éº„Éà
            const report = resolver.generateOptimizationReport(testFiles, optimizedOrder);
            console.log('üìà ÊúÄÈÅ©Âåñ„É¨„Éù„Éº„Éà:', report);
            
            return {
                originalOrder: testFiles,
                optimizedOrder: optimizedOrder,
                issues: issues,
                statistics: stats,
                report: report
            };
        }).catch(error => {
            console.error('‚ùå „ÉÜ„Çπ„ÉàÂ§±Êïó:', error);
        });
        
    } else {
        console.error('‚ùå Dependency Resolver not initialized');
        return null;
    }
};

// ‰æùÂ≠òÈñ¢‰øÇÁä∂Ê≥ÅÁ¢∫Ë™ç
window.checkDependencyStatus = function() {
    if (window.NAGANO3_DEPENDENCY_RESOLVER) {
        const debugInfo = window.NAGANO3_DEPENDENCY_RESOLVER.getDebugInfo();
        console.log('üîó Dependency Resolver Debug Info:', debugInfo);
        
        // ÂèØË¶ñÂåñ„Éá„Éº„Çø
        const vizData = window.NAGANO3_DEPENDENCY_RESOLVER.getVisualizationData();
        console.log('üìä ÂèØË¶ñÂåñ„Éá„Éº„Çø:', vizData);
        
        return { debugInfo, vizData };
    } else {
        console.error('‚ùå Dependency Resolver not initialized');
        return null;
    }
};

// Âæ™Áí∞‰æùÂ≠òÊ§úÂá∫„ÉÜ„Çπ„Éà
window.testCircularDependencies = function() {
    if (window.NAGANO3_DEPENDENCY_RESOLVER) {
        const resolver = window.NAGANO3_DEPENDENCY_RESOLVER;
        
        // ÊÑèÂõ≥ÁöÑ„Å´Âæ™Áí∞‰æùÂ≠ò„Çí‰ΩúÊàê„Åó„Å¶„ÉÜ„Çπ„Éà
        resolver.addDependency('test_a.js', ['test_b.js']);
        resolver.addDependency('test_b.js', ['test_c.js']);
        resolver.addDependency('test_c.js', ['test_a.js']);
        
        const circularDeps = resolver.detectCircularDependencies();
        console.log('üîÑ Âæ™Áí∞‰æùÂ≠ò„ÉÜ„Çπ„ÉàÁµêÊûú:', circularDeps);
        
        return circularDeps;
    } else {
        console.error('‚ùå Dependency Resolver not initialized');
        return null;
    }
};

console.log('üîó NAGANO-3 Dependency Resolver System Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü');