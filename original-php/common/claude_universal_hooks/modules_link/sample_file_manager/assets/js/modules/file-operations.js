
// CAIDS character_limit Hook
// CAIDS character_limit Hook - Âü∫Êú¨ÂÆüË£Ö
console.log('‚úÖ character_limit Hook loaded');

// CAIDS ajax_integration Hook
// CAIDS ajax_integration Hook - Âü∫Êú¨ÂÆüË£Ö
console.log('‚úÖ ajax_integration Hook loaded');

// CAIDS error_handling Hook

// CAIDS „Ç®„É©„ÉºÂá¶ÁêÜHook - ÂÆåÂÖ®ÂÆüË£Ö
window.CAIDS_ERROR_HANDLER = {
    isActive: true,
    errorCount: 0,
    errorHistory: [],
    
    initialize: function() {
        this.setupGlobalErrorHandler();
        this.setupUnhandledPromiseRejection();
        this.setupNetworkErrorHandler();
        console.log('‚ö†Ô∏è CAIDS „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†ÂÆåÂÖ®ÂàùÊúüÂåñ');
    },
    
    setupGlobalErrorHandler: function() {
        window.addEventListener('error', (event) => {
            this.handleError({
                type: 'JavaScript Error',
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: event.error?.stack
            });
        });
    },
    
    setupUnhandledPromiseRejection: function() {
        window.addEventListener('unhandledrejection', (event) => {
            this.handleError({
                type: 'Unhandled Promise Rejection',
                message: event.reason?.message || String(event.reason),
                stack: event.reason?.stack
            });
        });
    },
    
    setupNetworkErrorHandler: function() {
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            try {
                const response = await originalFetch.apply(this, args);
                if (!response.ok) {
                    window.CAIDS_ERROR_HANDLER.handleError({
                        type: 'Network Error',
                        message: `HTTP ${response.status}: ${response.statusText}`,
                        url: args[0]
                    });
                }
                return response;
            } catch (error) {
                window.CAIDS_ERROR_HANDLER.handleError({
                    type: 'Network Fetch Error',
                    message: error.message,
                    url: args[0]
                });
                throw error;
            }
        };
    },
    
    handleError: function(errorInfo) {
        this.errorCount++;
        this.errorHistory.push({...errorInfo, timestamp: new Date().toISOString()});
        
        console.error('üö® CAIDS Error Handler:', errorInfo);
        this.showErrorNotification(errorInfo);
        this.reportError(errorInfo);
    },
    
    showErrorNotification: function(errorInfo) {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 999999;
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: white; padding: 15px 20px; border-radius: 8px;
            max-width: 350px; box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            font-size: 13px; font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            border: 2px solid #ff6666; animation: caids-error-shake 0.5s ease-in-out;
        `;
        errorDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 18px;">üö®</span>
                <div>
                    <strong>„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü</strong><br>
                    <small style="opacity: 0.9;">${errorInfo.type}: ${errorInfo.message}</small>
                </div>
            </div>
        `;
        
        // CSS Animation
        if (!document.getElementById('caids-error-styles')) {
            const style = document.createElement('style');
            style.id = 'caids-error-styles';
            style.textContent = `
                @keyframes caids-error-shake {
                    0%, 100% { transform: translateX(0); }
                    25% { transform: translateX(-5px); }
                    75% { transform: translateX(5px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        document.body.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), 7000);
    },
    
    reportError: function(errorInfo) {
        // „Ç®„É©„Éº„É¨„Éù„Éº„ÉàÁîüÊàê„ÉªÈÄÅ‰ø°ÔºàÂ∞ÜÊù•„ÅÆÊã°ÂºµÁî®Ôºâ
        const report = {
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href,
            errorCount: this.errorCount,
            sessionId: this.getSessionId(),
            ...errorInfo
        };
        
        console.log('üìã CAIDS Error Report:', report);
        localStorage.setItem('caids_last_error', JSON.stringify(report));
    },
    
    getSessionId: function() {
        let sessionId = sessionStorage.getItem('caids_session_id');
        if (!sessionId) {
            sessionId = 'caids_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            sessionStorage.setItem('caids_session_id', sessionId);
        }
        return sessionId;
    },
    
    getErrorStats: function() {
        return {
            totalErrors: this.errorCount,
            recentErrors: this.errorHistory.slice(-10),
            sessionId: this.getSessionId()
        };
    }
};

window.CAIDS_ERROR_HANDLER.initialize();

/**
 * üî∏ üì§ „Éï„Ç°„Ç§„É´Êìç‰Ωú„É¢„Ç∏„É•„Éº„É´ - CAIDSÁµ±ÂêàÁâà
 * „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Éª„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÉªÂ§âÊèõÊ©üËÉΩ„ÅÆÂåÖÊã¨ÂÆüË£Ö
 */

class FileOperationsModule {
    constructor() {
        this.uploadQueue = [];
        this.processingFiles = new Map();
        this.supportedFormats = {
            images: ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'],
            documents: ['pdf', 'doc', 'docx', 'txt', 'csv', 'xlsx'],
            archives: ['zip', 'rar', '7z', 'tar', 'gz']
        };
        
        // CAIDSÈáèÂ≠êÂåñHooksÈÅ©Áî®
        this.hooks = {
            upload: 'üî∏ üì§ „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ_h',
            download: 'üî∏ üì• „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ_h',
            convert: 'üî∏ üîÑ Â§âÊèõ_h',
            security: 'üî∏ üõ°Ô∏è „Çª„Ç≠„É•„É™„ÉÜ„Ç£_h',
            validation: 'üî∏ ‚úÖ Ê§úË®º_h'
        };
        
        this.initializeFileOperations();
    }
    
    initializeFileOperations() {
        console.log('üî∏ üì§ „Éï„Ç°„Ç§„É´Êìç‰Ωú„É¢„Ç∏„É•„Éº„É´ÂàùÊúüÂåñ‰∏≠...');
        
        // „Éï„Ç°„Ç§„É´„Éâ„É≠„ÉÉ„Éó„Çæ„Éº„É≥Ë®≠ÂÆö
        this.setupDropZone();
        
        // „Éó„É≠„Ç∞„É¨„Çπ„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞ÂàùÊúüÂåñ
        this.setupProgressTracking();
        
        // „Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÅ„Çß„ÉÉ„ÇØÂàùÊúüÂåñ
        this.setupSecurityValidation();
        
        console.log('‚úÖ „Éï„Ç°„Ç§„É´Êìç‰Ωú„É¢„Ç∏„É•„Éº„É´ÂàùÊúüÂåñÂÆå‰∫Ü');
    }
    
    setupDropZone() {
        const dropZone = document.querySelector('.upload-zone, #uploadArea');
        if (!dropZone) return;
        
        // „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Ç§„Éô„É≥„Éà
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });
        
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            
            const files = Array.from(e.dataTransfer.files);
            this.handleMultipleFiles(files);
        });
        
        // „ÇØ„É™„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
        dropZone.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.accept = '*/*';
            input.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                this.handleMultipleFiles(files);
            });
            input.click();
        });
    }
    
    async handleMultipleFiles(files) {
        console.log(`üî∏ üì§ ${files.length}ÂÄã„ÅÆ„Éï„Ç°„Ç§„É´Âá¶ÁêÜÈñãÂßã`);
        
        for (const file of files) {
            await this.processFileUpload(file);
        }
    }
    
    async processFileUpload(file) {
        const fileId = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // CAIDSÈáèÂ≠êÂåñ„Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÅ„Çß„ÉÉ„ÇØ
        const securityCheck = this.validateFileSecurity(file);
        if (!securityCheck.valid) {
            this.showError(`üõ°Ô∏è „Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÅ„Çß„ÉÉ„ÇØÂ§±Êïó: ${securityCheck.reason}`, file.name);
            return;
        }
        
        // „Éó„É≠„Ç∞„É¨„Çπ„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞ÈñãÂßã
        this.startProgressTracking(fileId, file);
        
        try {
            // ÂÆüÈöõ„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂá¶ÁêÜ
            const uploadResult = await this.executeUpload(file, fileId);
            
            // ÊàêÂäüÂá¶ÁêÜ
            this.handleUploadSuccess(uploadResult, file);
            
            // CAIDSÁµ±Âêà„É≠„Ç∞
            this.logFileOperation('upload_success', {
                fileId,
                fileName: file.name,
                fileSize: file.size,
                processingTime: uploadResult.processingTime
            });
            
        } catch (error) {
            // CAIDSÈáèÂ≠êÂåñ„Ç®„É©„ÉºÂá¶ÁêÜ
            this.handleUploadError(error, file, fileId);
        }
    }
    
    validateFileSecurity(file) {
        // „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÉÅ„Çß„ÉÉ„ÇØ (50MBÂà∂Èôê)
        if (file.size > 50 * 1024 * 1024) {
            return {
                valid: false,
                reason: '„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„Åå50MB„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô'
            };
        }
        
        // Êã°ÂºµÂ≠ê„ÉÅ„Çß„ÉÉ„ÇØ
        const extension = file.name.split('.').pop().toLowerCase();
        const dangerousExtensions = ['exe', 'bat', 'cmd', 'scr', 'pif', 'com'];
        
        if (dangerousExtensions.includes(extension)) {
            return {
                valid: false,
                reason: 'Âç±Èô∫„Å™Êã°ÂºµÂ≠ê„ÅÆ„Éï„Ç°„Ç§„É´„Åß„Åô'
            };
        }
        
        // MIME„Çø„Ç§„Éó„ÉÅ„Çß„ÉÉ„ÇØ
        if (file.type && file.type.includes('application/octet-stream')) {
            return {
                valid: false,
                reason: '„Éï„Ç°„Ç§„É´„Çø„Ç§„Éó„Åå‰∏çÊòé„Åß„Åô'
            };
        }
        
        return { valid: true };
    }
    
    startProgressTracking(fileId, file) {
        // „Éó„É≠„Ç∞„É¨„ÇπË¶ÅÁ¥†‰ΩúÊàê
        const progressContainer = document.getElementById('uploadProgress') || this.createProgressContainer();
        
        const progressItem = document.createElement('div');
        progressItem.className = 'upload-progress-item';
        progressItem.id = `progress_${fileId}`;
        progressItem.innerHTML = `
            <div class="progress-info">
                <span class="file-name">${file.name}</span>
                <span class="file-size">${this.formatFileSize(file.size)}</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" data-progress="0"></div>
                <span class="progress-percentage">0%</span>
            </div>
            <div class="progress-status">Ê∫ñÂÇô‰∏≠...</div>
        `;
        
        progressContainer.appendChild(progressItem);
    }
    
    async executeUpload(file, fileId) {
        const startTime = Date.now();
        
        return new Promise((resolve, reject) => {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('fileId', fileId);
            formData.append('timestamp', Date.now());
            
            const xhr = new XMLHttpRequest();
            
            // „Éó„É≠„Ç∞„É¨„Çπ„Ç§„Éô„É≥„Éà
            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                    const percentage = Math.round((e.loaded / e.total) * 100);
                    this.updateProgress(fileId, percentage, '„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠...');
                }
            });
            
            // ÂÆå‰∫Ü„Ç§„Éô„É≥„Éà
            xhr.addEventListener('load', () => {
                if (xhr.status === 200) {
                    const response = JSON.parse(xhr.responseText);
                    response.processingTime = Date.now() - startTime;
                    resolve(response);
                } else {
                    reject(new Error(`„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂ§±Êïó: HTTP ${xhr.status}`));
                }
            });
            
            // „Ç®„É©„Éº„Ç§„Éô„É≥„Éà
            xhr.addEventListener('error', () => {
                reject(new Error('„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº'));
            });
            
            // „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆüË°å
            xhr.open('POST', 'api/upload.php');
            xhr.send(formData);
        });
    }
    
    updateProgress(fileId, percentage, status) {
        const progressItem = document.getElementById(`progress_${fileId}`);
        if (!progressItem) return;
        
        const progressBar = progressItem.querySelector('.progress-bar');
        const progressPercentage = progressItem.querySelector('.progress-percentage');
        const progressStatus = progressItem.querySelector('.progress-status');
        
        progressBar.style.width = `${percentage}%`;
        progressBar.setAttribute('data-progress', percentage);
        progressPercentage.textContent = `${percentage}%`;
        progressStatus.textContent = status;
        
        // ÂÆå‰∫ÜÊôÇ„ÅÆËâ≤Â§âÊõ¥
        if (percentage === 100) {
            progressBar.classList.add('complete');
        }
    }
    
    handleUploadSuccess(result, file) {
        console.log('üî∏ ‚úÖ „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊàêÂäü:', result);
        
        // ÊàêÂäüÈÄöÁü•
        this.showSuccess(`üì§ ${file.name} „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫Ü`, {
            fileId: result.file_id,
            size: this.formatFileSize(file.size),
            time: `${result.processingTime}ms`
        });
        
        // „Éï„Ç°„Ç§„É´„É™„Çπ„Éà„Å´ËøΩÂä†
        this.addToFileList(result, file);
        
        // „Éó„É¨„Éì„É•„ÉºÁîüÊàêÔºàÁîªÂÉè„ÅÆÂ†¥ÂêàÔºâ
        if (file.type.startsWith('image/')) {
            this.generateImagePreview(file, result);
        }
    }
    
    addToFileList(result, file) {
        const fileList = document.getElementById('downloadableFiles') || this.createFileList();
        
        const fileItem = document.createElement('div');
        fileItem.className = 'file-list-item';
        fileItem.dataset.fileId = result.file_id;
        fileItem.innerHTML = `
            <div class="file-icon">
                ${this.getFileIcon(file.type, file.name)}
            </div>
            <div class="file-info">
                <div class="file-name">${file.name}</div>
                <div class="file-details">
                    ${this.formatFileSize(file.size)} ‚Ä¢ ${file.type || 'Unknown'}
                </div>
            </div>
            <div class="file-actions">
                <button onclick="fileOps.downloadFile('${result.file_id}')" class="btn btn-sm btn-secondary">
                    üì• „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
                </button>
                <button onclick="fileOps.deleteFile('${result.file_id}')" class="btn btn-sm btn-danger">
                    üóëÔ∏è ÂâäÈô§
                </button>
            </div>
        `;
        
        fileList.appendChild(fileItem);
    }
    
    async downloadFile(fileId) {
        try {
            console.log(`üî∏ üì• „Éï„Ç°„Ç§„É´„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÈñãÂßã: ${fileId}`);
            
            const response = await fetch(`api/download.php?file_id=${fileId}`);
            
            if (!response.ok) {
                throw new Error(`„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÂ§±Êïó: HTTP ${response.status}`);
            }
            
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = response.headers.get('Content-Disposition')?.split('filename=')[1] || 'download';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            this.showSuccess('üì• „ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÂÆå‰∫Ü', a.download);
            
        } catch (error) {
            this.showError('üì• „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Ç®„É©„Éº', error.message);
        }
    }
    
    async createZipDownload() {
        const selectedFiles = this.getSelectedFiles();
        
        if (selectedFiles.length === 0) {
            this.showWarning('üì¶ „Éï„Ç°„Ç§„É´ÈÅ∏Êäû', 'ZIP‰ΩúÊàê„Åô„Çã„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
            return;
        }
        
        try {
            console.log('üî∏ üì¶ ZIP‰ΩúÊàêÈñãÂßã...');
            
            const response = await fetch('api/create-zip.php', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    files: selectedFiles,
                    zipName: `archive_${Date.now()}.zip`
                })
            });
            
            if (!response.ok) {
                throw new Error(`ZIP‰ΩúÊàêÂ§±Êïó: HTTP ${response.status}`);
            }
            
            const result = await response.json();
            this.showSuccess('üì¶ ZIP‰ΩúÊàêÂÆå‰∫Ü', `${result.fileCount}ÂÄã„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂúßÁ∏Æ`);
            
            // ZIPËá™Âãï„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
            this.downloadFile(result.zipId);
            
        } catch (error) {
            this.showError('üì¶ ZIP‰ΩúÊàê„Ç®„É©„Éº', error.message);
        }
    }
    
    // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£„É°„ÇΩ„ÉÉ„Éâ
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    getFileIcon(mimeType, fileName) {
        if (mimeType?.startsWith('image/')) return 'üñºÔ∏è';
        if (mimeType?.startsWith('video/')) return 'üé•';
        if (mimeType?.startsWith('audio/')) return 'üéµ';
        if (mimeType?.includes('pdf')) return 'üìÑ';
        if (mimeType?.includes('zip') || mimeType?.includes('rar')) return 'üì¶';
        if (fileName?.endsWith('.txt')) return 'üìù';
        return 'üìÑ';
    }
    
    createProgressContainer() {
        const container = document.createElement('div');
        container.id = 'uploadProgress';
        container.className = 'upload-progress-container';
        
        const targetArea = document.querySelector('.upload-zone') || document.body;
        targetArea.appendChild(container);
        
        return container;
    }
    
    // CAIDSÁµ±Âêà„É°„ÇΩ„ÉÉ„Éâ
    showSuccess(message, details) {
        if (window.demoSystem) {
            window.demoSystem.log('fileops', 'success', `${message} ${details ? JSON.stringify(details) : ''}`);
        }
        console.log('‚úÖ', message, details);
    }
    
    showError(message, details) {
        if (window.demoSystem) {
            window.demoSystem.log('fileops', 'error', `${message} ${details || ''}`);
        }
        console.error('‚ùå', message, details);
    }
    
    showWarning(message, details) {
        if (window.demoSystem) {
            window.demoSystem.log('fileops', 'warning', `${message} ${details || ''}`);
        }
        console.warn('‚ö†Ô∏è', message, details);
    }
    
    logFileOperation(operation, data) {
        if (window.demoSystem) {
            window.demoSystem.log('fileops', 'info', `[${operation}] ${JSON.stringify(data)}`);
        }
    }
    
    getSelectedFiles() {
        const checkboxes = document.querySelectorAll('.file-list-item input[type="checkbox"]:checked');
        return Array.from(checkboxes).map(cb => cb.value);
    }
    
    // „ÉÜ„Çπ„ÉàÁî®„É°„ÇΩ„ÉÉ„Éâ
    async runTests() {
        const results = {
            upload: await this.testFileUpload(),
            download: await this.testFileDownload(),
            security: await this.testSecurityValidation(),
            compression: await this.testCompression()
        };
        
        console.log('üî∏ üì§ „Éï„Ç°„Ç§„É´Êìç‰Ωú„ÉÜ„Çπ„ÉàÁµêÊûú:', results);
        return results;
    }
    
    async testFileUpload() {
        // „ÉÜ„Çπ„ÉàÁî®„ÉÄ„Éü„Éº„Éï„Ç°„Ç§„É´‰ΩúÊàê
        const testFile = new File(['test content'], 'test.txt', {
            type: 'text/plain'
        });
        
        try {
            const result = await this.processFileUpload(testFile);
            return { success: true, message: '„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÉÜ„Çπ„ÉàÊàêÂäü' };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }
}

// „Ç∞„É≠„Éº„Éê„É´‰ΩøÁî®ÂèØËÉΩ„Å´
window.FileOperationsModule = FileOperationsModule;

// „Ç§„É≥„Çπ„Çø„É≥„Çπ‰ΩúÊàê
window.fileOps = new FileOperationsModule();

console.log('üî∏ üì§ „Éï„Ç°„Ç§„É´Êìç‰Ωú„É¢„Ç∏„É•„Éº„É´Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü');