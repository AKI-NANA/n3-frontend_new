# 🛠️ 専用Hooks動的生成システム修正指示書

## 🎯 **修正目的**

現在の専用Hooks生成システムを、HTMLと開発指示書の内容に完全適応する動的システムに修正する。

---

## 🚨 **現状の問題点**

### **❌ 固定的質問システム**
- HTMLにボタンが1個でも10個でも同じ質問パターン
- 要素の具体的内容を読み取らず汎用的質問のみ
- 開発指示書との連動性が低い
- 機能推測が不十分

### **❌ 具体例**
```
現状の質問:
「このボタンの動作は理解していますか？」

あるべき質問:
「在庫管理システムで検出された4個のボタン（入庫・出庫・在庫確認・レポート生成）のうち、
特に『入庫ボタン』は商品コード入力→在庫数追加→データベース更新の流れになりますが、
入庫時の重複商品チェック方法は？」
```

---

## ✅ **修正後の理想システム**

### **🔄 動的質問生成フロー**

#### **Step 1: 完全解析**
```python
class DynamicHooksAnalyzer:
    """HTML+指示書の完全解析"""
    
    def complete_analysis(self, html_content, instruction_content):
        analysis_result = {
            'elements_count': self._count_all_elements(html_content),
            'function_inference': self._infer_functions(html_content, instruction_content),
            'business_logic': self._extract_business_logic(instruction_content),
            'complexity_level': self._assess_complexity(),
            'integration_requirements': self._detect_integrations()
        }
        return analysis_result
    
    def _count_all_elements(self, html_content):
        """全要素の詳細カウント"""
        return {
            'buttons': {
                'count': len(re.findall(r'<button|<input[^>]*type=["\']button', html_content)),
                'details': self._extract_button_details(html_content)
            },
            'forms': {
                'count': len(re.findall(r'<form', html_content)),
                'details': self._extract_form_details(html_content)
            },
            'inputs': {
                'count': len(re.findall(r'<input', html_content)),
                'types': self._categorize_input_types(html_content)
            },
            'tables': {
                'count': len(re.findall(r'<table', html_content)),
                'data_display': self._analyze_table_structure(html_content)
            }
        }
    
    def _infer_functions(self, html_content, instruction_content):
        """機能推測エンジン"""
        
        function_patterns = {
            'data_management': {
                'keywords': ['登録', '編集', '削除', '一覧', 'CRUD'],
                'html_indicators': ['form', 'table', 'button'],
                'inferred_functions': []
            },
            'calculation': {
                'keywords': ['計算', '合計', '集計', '統計'],
                'html_indicators': ['onclick', 'calculate', 'math'],
                'inferred_functions': []
            },
            'reporting': {
                'keywords': ['レポート', '出力', 'CSV', 'PDF'],
                'html_indicators': ['download', 'export', 'report'],
                'inferred_functions': []
            },
            'ai_integration': {
                'keywords': ['AI', '機械学習', '自動', '予測', '分類'],
                'html_indicators': ['ai', 'predict', 'auto'],
                'inferred_functions': []
            }
        }
        
        for category, pattern in function_patterns.items():
            # キーワードマッチング
            keyword_matches = sum(1 for kw in pattern['keywords'] 
                                if kw in instruction_content)
            
            # HTML要素マッチング
            html_matches = sum(1 for indicator in pattern['html_indicators']
                             if indicator in html_content.lower())
            
            confidence = (keyword_matches + html_matches) / (len(pattern['keywords']) + len(pattern['html_indicators']))
            
            if confidence > 0.3:
                pattern['confidence'] = confidence
                pattern['detected_elements'] = self._get_matching_elements(html_content, pattern['html_indicators'])
        
        return function_patterns
```

#### **Step 2: 動的質問生成**
```python
class DynamicQuestionGenerator:
    """解析結果に基づく動的質問生成"""
    
    def generate_adaptive_questions(self, analysis_result):
        dynamic_questions = []
        
        # ボタン数に応じた質問生成
        button_questions = self._generate_button_questions(analysis_result['elements_count']['buttons'])
        dynamic_questions.extend(button_questions)
        
        # 機能推測に基づく質問生成
        function_questions = self._generate_function_questions(analysis_result['function_inference'])
        dynamic_questions.extend(function_questions)
        
        # 複雑度に応じた質問生成
        complexity_questions = self._generate_complexity_questions(analysis_result['complexity_level'])
        dynamic_questions.extend(complexity_questions)
        
        return dynamic_questions
    
    def _generate_button_questions(self, button_data):
        """ボタン数・内容に応じた動的質問"""
        
        button_count = button_data['count']
        button_details = button_data['details']
        
        if button_count == 0:
            return ["このシステムにボタン機能はありませんが、将来的にボタン追加の予定はありますか？"]
        
        elif button_count == 1:
            button = button_details[0]
            return [
                f"検出された1個のボタン「{button['text']}」の具体的な処理内容は？",
                f"このボタンが失敗した場合のエラーハンドリング方法は？",
                f"処理完了時のユーザーへのフィードバック方法は？"
            ]
        
        elif 2 <= button_count <= 5:
            button_list = [btn['text'] for btn in button_details]
            return [
                f"検出された{button_count}個のボタン（{', '.join(button_list)}）の実行順序・依存関係は？",
                f"これらのボタン間でのデータ連携方法は？",
                f"複数ボタンの同時押下防止機能は必要ですか？",
                *[f"「{btn['text']}」ボタンの詳細処理フローは？" for btn in button_details]
            ]
        
        elif button_count > 5:
            primary_buttons = button_details[:3]  # 主要3個に絞る
            return [
                f"多数（{button_count}個）のボタンが検出されました。主要機能のボタン3個を教えてください。",
                f"ボタンのグループ化・カテゴリ分けは必要ですか？",
                f"ボタンの動的表示・非表示制御は必要ですか？",
                *[f"主要ボタン「{btn['text']}」の処理優先度は？" for btn in primary_buttons]
            ]
    
    def _generate_function_questions(self, function_inference):
        """推測された機能に基づく質問"""
        
        questions = []
        
        for category, function_data in function_inference.items():
            if function_data.get('confidence', 0) > 0.5:
                
                if category == 'data_management':
                    questions.extend([
                        f"データ管理機能（信頼度{function_data['confidence']:.1%}）が推測されます。主なデータ操作は？",
                        "データの一意性制約・重複チェックルールは？",
                        "データ削除時の確認・復元機能は必要ですか？",
                        "データのバックアップ・履歴管理は必要ですか？"
                    ])
                
                elif category == 'calculation':
                    questions.extend([
                        f"計算機能（信頼度{function_data['confidence']:.1%}）が推測されます。計算式・アルゴリズムは？",
                        "計算結果の精度・桁数の要件は？",
                        "計算エラー時の代替処理は？",
                        "計算履歴・過程の保存は必要ですか？"
                    ])
                
                elif category == 'reporting':
                    questions.extend([
                        f"レポート機能（信頼度{function_data['confidence']:.1%}）が推測されます。出力形式は？",
                        "レポートの自動生成スケジュールは？",
                        "レポートのフィルタ・ソート機能は？",
                        "レポートのアクセス権限制御は？"
                    ])
                
                elif category == 'ai_integration':
                    questions.extend([
                        f"AI統合機能（信頼度{function_data['confidence']:.1%}）が推測されます。使用するAIツールは？",
                        "・DEEPSEEK（コード生成特化）",
                        "・Ollama（多モデル対応）", 
                        "・OpenAI API（高精度優先）",
                        "・カスタムモデル（独自学習）",
                        "AI学習データの取得元・更新頻度は？",
                        "AI推論結果の信頼度表示は必要ですか？",
                        "AI処理失敗時のフォールバック機能は？"
                    ])
        
        return questions
    
    def _generate_complexity_questions(self, complexity_level):
        """システム複雑度に応じた質問"""
        
        if complexity_level == 'simple':
            return [
                "シンプルなシステムですが、将来の拡張性は考慮しますか？",
                "最小限の機能で十分ですか？"
            ]
        
        elif complexity_level == 'medium':
            return [
                "中程度の複雑さのシステムです。モジュール分割・設計方針は？",
                "パフォーマンス要件（応答時間・同時ユーザー数）は？",
                "テスト・デバッグ方法の要件は？"
            ]
        
        elif complexity_level == 'complex':
            return [
                "高複雑度システムです。アーキテクチャ設計パターンは？",
                "スケーラビリティ・可用性の要件は？",
                "監視・ログ・運用の要件は？",
                "セキュリティ要件（認証・認可・監査）は？",
                "災害復旧・バックアップ戦略は？"
            ]
```

#### **Step 3: 適応型Hooks生成**
```python
class AdaptiveHooksBuilder:
    """解析・質問結果に基づく適応型hooks生成"""
    
    def build_adaptive_hooks(self, analysis_result, question_responses):
        adaptive_hooks = {}
        
        # ボタン個別hooks生成
        for button in analysis_result['elements_count']['buttons']['details']:
            button_hook = self._build_button_specific_hook(button, question_responses)
            adaptive_hooks[f"btn_{button['id']}"] = button_hook
        
        # 機能統合hooks生成
        for category, function_data in analysis_result['function_inference'].items():
            if function_data.get('confidence', 0) > 0.5:
                integration_hook = self._build_function_integration_hook(category, function_data, question_responses)
                adaptive_hooks[f"integration_{category}"] = integration_hook
        
        return adaptive_hooks
    
    def _build_button_specific_hook(self, button_info, responses):
        """ボタン固有の詳細hook生成"""
        
        return {
            'hook_type': 'button_specific_adaptive',
            'button_info': button_info,
            'adaptive_implementation': {
                'frontend_logic': self._generate_adaptive_frontend(button_info, responses),
                'backend_logic': self._generate_adaptive_backend(button_info, responses),
                'error_handling': self._generate_adaptive_error_handling(button_info, responses),
                'testing_strategy': self._generate_adaptive_testing(button_info, responses)
            },
            'integration_points': self._identify_integration_points(button_info, responses),
            'performance_requirements': self._extract_performance_requirements(responses)
        }
```

---

## 📋 **修正実装手順**

### **Phase 1: 解析エンジンの強化**
1. HTML要素の完全カウント・詳細抽出
2. 開発指示書との相関分析
3. 機能推測エンジンの実装
4. 複雑度評価システムの実装

### **Phase 2: 動的質問生成システム**
1. 要素数に応じた質問パターン
2. 機能推測に基づく専門質問
3. プロジェクト特性適応質問
4. AI統合の詳細質問復活

### **Phase 3: 適応型Hooks生成**
1. 解析結果に基づくhooks設計
2. 質問回答に基づく実装仕様
3. 統合・連携hooks生成
4. 検証・テスト要件生成

### **Phase 4: 完全統合システム**
1. 汎用hooks（190種類）との統合
2. 1つのMD出力システム
3. 他プロジェクト再利用機能
4. 品質保証・検証システム

---

## 🎯 **修正後の期待効果**

### **✅ 完全適応**
- HTMLの要素数・内容に完全適応
- 開発指示書の要求に完全対応
- プロジェクト特性を完全反映

### **✅ 高精度質問**
- ボタン1個でも10個でも最適な質問
- 機能推測に基づく専門的質問
- AI統合の詳細設定質問

### **✅ 実用性**
- どんなプロジェクトでも確実対応
- 人間の知識を最大活用
- 再利用可能な高品質システム

**この修正により、真に実用的で柔軟な専用Hooks生成システムが完成します。**