ğŸ’» C-1. ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆã¨å‚ç…§UI å®Ÿè£…éª¨å­ã“ã®æ©Ÿèƒ½ã¯ã€ä¸»ã«ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆã‚µãƒ¼ãƒ“ã‚¹ã¨ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®å‹•çš„UIã®2ã¤ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§æ§‹æˆã•ã‚Œã¾ã™ã€‚1. âš™ï¸ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼šçŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆã‚µãƒ¼ãƒ“ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹: /services/knowledge_base/IndexerService.ts (æ–°è¦)ã“ã®ã‚µãƒ¼ãƒ“ã‚¹ã¯ã€æŒ‡å®šã•ã‚ŒãŸãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚©ãƒ«ãƒ€ã‚’å®šæœŸçš„ã«ã‚¹ã‚­ãƒ£ãƒ³ã—ã€DBã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚TypeScript// /services/knowledge_base/IndexerService.ts

import * as fs from 'fs/promises';
import * as path from 'path';
// ğŸ’¡ DBã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨LLMã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ç”Ÿæˆã‚µãƒ¼ãƒ“ã‚¹ã‚’æƒ³å®š
// import { dbClient } from '@/lib/db';
// import { generateKeywordsFromText } from '@/services/ai/KeywordGenerator';

interface KnowledgeIndex {
    index_id: string; // UUID
    file_name: string;
    file_path: string;
    summary: string;
    keywords: string[]; // JSON Arrayã¨ã—ã¦DBã«æ ¼ç´
    last_modified: Date;
}

const TARGET_FOLDER = process.env.LOCAL_KNOWLEDGE_PATH || path.resolve('/path/to/local/data');
const SUMMARY_LENGTH = 5; // æ¦‚è¦ã¨ã—ã¦æŠ½å‡ºã™ã‚‹è¡Œæ•°

/**
 * (ï¼‘) ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆï¼šæŒ‡å®šãƒ•ã‚©ãƒ«ãƒ€ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã€DBã«JSONå½¢å¼ã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä¿å­˜ã™ã‚‹
 */
export async function buildKnowledgeIndex(): Promise<void> {
    console.log(`[IndexerService] Starting scan of: ${TARGET_FOLDER}`);
    const files = await fs.readdir(TARGET_FOLDER);
    const newIndexes: KnowledgeIndex[] = [];

    for (const fileName of files) {
        const filePath = path.join(TARGET_FOLDER, fileName);
        const stats = await fs.stat(filePath);

        if (stats.isFile()) {
            const content = await fs.readFile(filePath, 'utf-8');
            const lines = content.split('\n');
            
            // æ¦‚è¦ï¼ˆå†’é ­æ•°è¡Œï¼‰ã‚’æŠ½å‡º
            const summaryText = lines.slice(0, SUMMARY_LENGTH).join('\n');
            
            // ğŸ’¡ é–¢é€£ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®æŠ½å‡ºï¼ˆLLMé€£æºã‚’æƒ³å®šï¼‰
            // keywords: string[] = await generateKeywordsFromText(summaryText); 
            const keywords = [`${path.basename(fileName, path.extname(fileName))}`, 'local', 'data']; // ãƒ¢ãƒƒã‚¯

            const index: KnowledgeIndex = {
                index_id: crypto.randomUUID(),
                file_name: fileName,
                file_path: filePath,
                summary: summaryText,
                keywords: keywords,
                last_modified: stats.mtime,
            };
            newIndexes.push(index);
        }
    }

    // ğŸ’¡ DBã¸ã®ä¿å­˜å‡¦ç† (é‡è¤‡ãƒã‚§ãƒƒã‚¯ã¨æ›´æ–°/æ–°è¦æŒ¿å…¥)
    // await saveIndexesToDatabase(newIndexes);

    console.log(`[IndexerService] Indexing complete. ${newIndexes.length} files processed.`);
}

// ğŸ’¡ DBæ§‹é€ : index_id, file_name, file_path, summary, keywords (JSON Array), last_modified

// async function saveIndexesToDatabase(indexes: KnowledgeIndex[]) {
//     for (const index of indexes) {
//         // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚„ãƒ•ã‚¡ã‚¤ãƒ«åã€æœ€çµ‚æ›´æ–°æ™‚åˆ»ã‚’åŸºã«ã€æ—¢å­˜ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ã¾ãŸã¯æ–°è¦æŒ¿å…¥
//         // ...
//     }
// }
2. ğŸ–¥ï¸ ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼šå‚ç…§ãƒ‡ãƒ¼ã‚¿çµã‚Šè¾¼ã¿UIãƒ­ã‚¸ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹: /services/ai_pipeline/PromptBuilder.ts (æ–°è¦)ã“ã®ã‚µãƒ¼ãƒ“ã‚¹ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒUIã§é¸æŠã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã«åŸºã¥ãã€AIã¸ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚TypeScript// /services/ai_pipeline/PromptBuilder.ts

import { KnowledgeIndex } from '@/services/knowledge_base/IndexerService';

/**
 * (ï¼“) å‚ç…§ãƒ‡ãƒ¼ã‚¿çµã‚Šè¾¼ã¿æ©Ÿèƒ½ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠã«åŸºã¥ãã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«å‚ç…§ãƒ‡ãƒ¼ã‚¿ã‚’çµ„ã¿è¾¼ã‚€
 * @param basePrompt ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå…¥åŠ›ã—ãŸåŸºæœ¬ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
 * @param selectedIndexIds ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒUIã§é¸æŠã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®IDãƒªã‚¹ãƒˆ
 */
export async function buildAIPromptWithContext(basePrompt: string, selectedIndexIds: string[]): Promise<string> {
    if (selectedIndexIds.length === 0) {
        return basePrompt; // å‚ç…§ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯ã€åŸºæœ¬ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ãã®ã¾ã¾è¿”ã™
    }
    
    // ğŸ’¡ 1. é¸æŠã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹IDã«åŸºã¥ãã€DBã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã¨å†…å®¹ã‚’å–å¾—
    // const selectedIndexes = await getSelectedIndexesFromDB(selectedIndexIds); 
    // const fileContentsPromises = selectedIndexes.map(index => fs.readFile(index.file_path, 'utf-8'));
    // const fileContents = await Promise.all(fileContentsPromises);
    
    // ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿
    const selectedFilesContent = [
        { name: 'Manual_V1.pdf', content: 'V1ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã«ã¯ã€ä¾¡æ ¼è¨­å®šã®ãƒ­ã‚¸ãƒƒã‚¯ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™...' },
        { name: 'Q4_Strategy.txt', content: 'Q4ã§ã¯ã€ç©å…·ã®HTSã‚³ãƒ¼ãƒ‰ã¯9503ã‚’ä½¿ç”¨ã—ã€VEROãƒªã‚¹ã‚¯ã¯ç„¡è¦–ã—ã¦é«˜å€¤ã§è²©å£²ã™ã‚‹æˆ¦ç•¥ã§ã™...' }
    ];

    let contextString = "--- å‚ç…§ã•ã‚Œã‚‹çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ --- \n";
    let totalTokenCount = 0;
    
    for (const file of selectedFilesContent) {
        // ãƒˆãƒ¼ã‚¯ãƒ³æ¶ˆè²»ã‚’æŠ‘ãˆã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å†’é ­ã‚’åˆ¶é™ã—ãŸã‚Šã€ãƒˆãƒ¼ã‚¯ãƒ³æ•°ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†
        const limitedContent = file.content.substring(0, 5000); 
        contextString += `\n[ãƒ•ã‚¡ã‚¤ãƒ«å: ${file.name}]\n${limitedContent}\n`;
        // ğŸ’¡ å®Ÿéš›ã®ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã‚’è¨ˆç®—ã—ã€æœ€å¤§ãƒˆãƒ¼ã‚¯ãƒ³åˆ¶é™ã‚’è¶…ãˆãªã„ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
        // totalTokenCount += calculateTokens(limitedContent);
    }

    contextString += "\n--- çŸ¥è­˜ãƒ™ãƒ¼ã‚¹çµ‚äº† --- \n\n";

    // 2. çµ„ã¿è¾¼ã¿ãƒ­ã‚¸ãƒƒã‚¯
    // AIã¸ã®æŒ‡ç¤ºã‚’æ˜ç¢ºã«ã™ã‚‹System Instructionã‚’è¿½åŠ ã—ã€æ–‡è„ˆãƒ‡ãƒ¼ã‚¿ï¼ˆcontextStringï¼‰ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’çµåˆ
    const finalPrompt = 
        `ä»¥ä¸‹ã®çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã‚’å‚ç…§ã—ã€è³ªå•ã«å›ç­”ã—ã¦ãã ã•ã„ã€‚\n` +
        contextString + 
        `ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•: ${basePrompt}`;

    return finalPrompt;
}
3. ğŸ–¥ï¸ ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰UIï¼ˆUIè¡¨ç¤ºã®çµ±åˆï¼‰ç›®çš„: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç›´æ„Ÿçš„ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã€AIã®å‚ç…§ãƒ‡ãƒ¼ã‚¿ã‚’çµã‚Šè¾¼ã‚ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚UIè¦ç´ ãƒ­ã‚¸ãƒƒã‚¯ã‚µã‚¤ãƒ‰ãƒãƒ¼/æ¤œç´¢ãƒªã‚¹ãƒˆ**/api/knowledge/index-list/route.tsã‹ã‚‰çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åã€æ¦‚è¦ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰ã‚’å–å¾—ã—ã€è¡¨ç¤ºã™ã‚‹ã€‚ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ï¼‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã‚‹ã¨ã€é¸æŠã•ã‚ŒãŸindex_idãŒStateã«æ ¼ç´ã•ã‚Œã‚‹ã€‚AIå‘¼ã³å‡ºã—AIå‘¼ã³å‡ºã—æ™‚ã«ã€æ ¼ç´ã•ã‚ŒãŸindex_idãƒªã‚¹ãƒˆã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ï¼ˆbasePromptï¼‰ã‚’/api/ai/processãªã©ã®æ–°ã—ã„APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ**ã«æ¸¡ã—ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§**PromptBuilder.buildAIPromptWithContext**ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã€‚ğŸ’¡ åŠ¹æœã®ã¾ã¨ã‚ã‚³ã‚¹ãƒˆå‰Šæ¸›: AIãŒãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆæŒ‡å®šãƒ•ã‚©ãƒ«ãƒ€ï¼‰ã®å…¨å†…å®¹ã‚’æ¯å›èª­ã‚€ã®ã‚’é˜²ãã€ãƒˆãƒ¼ã‚¯ãƒ³æ¶ˆè²»ã‚’æŠ‘ãˆã¾ã™ã€‚ç²¾åº¦å‘ä¸Š: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒé–¢é€£æ€§ã®é«˜ã„ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚’é¸æŠã™ã‚‹ã“ã¨ã§ã€AIã«æä¾›ã•ã‚Œã‚‹æ–‡è„ˆãŒãƒã‚¤ã‚ºãªãæ˜ç¢ºã«ãªã‚Šã€å¿œç­”ã®ç²¾åº¦ãŒå‘ä¸Šã—ã¾ã™ã€‚